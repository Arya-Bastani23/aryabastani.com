{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/nbody/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"templateKey\": \"blog-post\",\n  \"published\": true,\n  \"title\": \"N-Body Orbit Simulation\",\n  \"slug\": \"nbody\",\n  \"date\": \"2022-10-02T00:00:00.000Z\",\n  \"featureImage\": \"images/solar_system_large.jpg\",\n  \"tags\": [\"Simulation\", \"Orbital Mechanics\"],\n  \"excerpt\": \"An introduction to the principles and methods required to implement an n-body simulator in Python.\",\n  \"pinned\": true\n};\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\nvar PostVideo = makeShortcode(\"PostVideo\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"introduction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Introduction\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This post will introduce the principles behind predicting the motion of gravitationally interacting objects. Using Python with some popular modules, we'll implement the principles from scratch.\"), mdx(PostVideo, {\n    video: solar_anim,\n    _autoplay: true,\n    mdxType: \"PostVideo\"\n  }), mdx(\"h1\", {\n    \"id\": \"prior-knowledge\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Prior Knowledge\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#prior-knowledge\",\n    \"aria-label\": \"prior knowledge permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"There are a few concepts that you should know before coming into this post, in general I try to explain everything clearly but it helps if you have prior exposure to these concepts.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NumPy Matrices:\"), \" We will use NumPy as the primary data storage and computation backbone. If you're not familiar with NumPy matrices take a look at \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://numpy.org/doc/stable/user/absolute_beginners.html\",\n    \"target\": \"_self\",\n    \"rel\": \"nofollow\"\n  }, \"this resource\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Numerical Integration for ODEs:\"), \" We use numerical integrators to solve this problem but we're building off prior knowledge of simpler cases from \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/blog/integrator-intro/\"\n  }, \"my blog post from before\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Gravitational Laws:\"), \" To be precise, we will be using Newton's law of universal gravitation that you may have seen in a physics course or you can \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation\",\n    \"target\": \"_self\",\n    \"rel\": \"nofollow\"\n  }, \"review it here\"), \".\")), mdx(\"h1\", {\n    \"id\": \"n-body-problem\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"N-Body Problem\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#n-body-problem\",\n    \"aria-label\": \"n body problem permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The n-body problem is to predict the individual motions of a group of objects interacting gravitationally. More precisely, given the initial conditions of a set of objects the goal is to predict the state of these objects over time when influenced by the gravity of all neighboring objects. Fields such as astronomy, space flight, and others that rely on the understanding of the positions and trajectories of celestial bodies utilize solutions to this problem. What makes this difficult is that for systems of more than two bodies, the math cannot be solved explicitly and therefore must be simulated.\"), mdx(\"p\", null, \"The next few sections will focus on concretely defining the core operations, principles, and theories that we will use moving into the implementation.\"), mdx(\"h1\", {\n    \"id\": \"general-goals\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"General Goals\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#general-goals\",\n    \"aria-label\": \"general goals permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"As with many problems, there are different methodologies behind how you may solve it. When developing this solution I focused on a few core principles.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Readable\"), \": Many operations can be written to run marginally faster at the expense of readability. As this post is meant to educate I focus on making code that is as self-explanatory as possible.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Adaptive\"), \": Depending on what you are simulating it may not make sense to generalize the integrator to only work in 3D. I wanted to produce a solution that adapts depending on the inputs and only computes the number of dimensions given.\")), mdx(\"h1\", {\n    \"id\": \"notation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Notation\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#notation\",\n    \"aria-label\": \"notation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I'll summarize the notation used for vectors, variable assignments, and some other structures that might seem foreign but will be explained through reading the post.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Notation\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Definition\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\vec{v}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Vector\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle v_1, ..., v_n \\\\rangle$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\vec{v_{12}}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Vector from 1 to 2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\vec{v_2} - \\\\vec{v_1}$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\lVert\\\\vec{v}\\\\rVert$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Vector Magnitude\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\sqrt{v_1^2 + ... + v_n^2}$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\hat{v}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Unit Vector\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\frac{\\\\vec{v}}{\\\\lVert\\\\vec{v}\\\\rVert}$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\vec{r}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Position Vector\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle x, y, z \\\\rangle$ in 3D\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\vec{v}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Velocity Vector\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle \\\\dot{x}, \\\\dot{y}, \\\\dot{z} \\\\rangle$ in 3D\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\vec{a}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Acceleration Vector\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle \\\\ddot{x}, \\\\ddot{y}, \\\\ddot{z} \\\\rangle$ in 3D\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\dot{\\\\vec{v}}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Vector Derivative\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\frac{d\\\\vec{v}}{dt}$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$X$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Object State\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\begin{bmatrix}\\\\vec{r} & \\\\vec{v}\\\\end{bmatrix}$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$X$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"System State\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\begin{bmatrix}X_1 \", \"\\\\\", \" X_2\\\\end{bmatrix} = \\\\begin{bmatrix}\\\\vec{r_1} & \\\\vec{v_1} \", \"\\\\\", \" \\\\vec{r_2} & \\\\vec{v_2}\\\\end{bmatrix}$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\dot{X}$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"State Derivative\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\begin{bmatrix}\\\\dot{X_1} \", \"\\\\\", \" \\\\dot{X_2}\\\\end{bmatrix} = \\\\begin{bmatrix}\\\\vec{v_1} & \\\\vec{a_1} \", \"\\\\\", \" \\\\vec{v_2} & \\\\vec{a_2}\\\\end{bmatrix}$\")))), mdx(\"h1\", {\n    \"id\": \"gravity-laws\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Gravity Laws\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#gravity-laws\",\n    \"aria-label\": \"gravity laws permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"In this section, I will give a brief overview of Newton'zs law of universal gravitation and extend the concept of gravitation between two bodies to all of our $n$ bodies.\"), mdx(\"h2\", {\n    \"id\": \"law-of-universal-gravitation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Law of Universal Gravitation\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#law-of-universal-gravitation\",\n    \"aria-label\": \"law of universal gravitation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Newton's law of gravitation states that any two bodies in space will be attracted to each other, where $m_1$ and $m_2$ are the masses of the two bodies, $r$ is the distance separating them, and $G$ is the gravitational constant. I've given the equation below in the scalar and vector form.\"), mdx(\"p\", null, \"$$\\nF = \\\\frac{G m_1 m_2}{r^2} = \\\\frac{G m_1 m_2}{\\\\lVert \\\\vec{r_2} - \\\\vec{r_1} \\\\rVert^2}\\n$$\"), mdx(\"p\", null, \"This equation only gives us the magnitude of the force, but it would be helpful to have the force as vector. If we multiply the prior with the unit vector pointing from body 1 to body 2 we can get the force acting on body 1 due to object 2 as a vector.\"), mdx(\"p\", null, \"$$\\n\\\\vec{F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{12}} = F\"), \"{12} \\\\hat{r_{12}}\\n$$\\n$$\\n=\\\\frac{G m_1 m_2}{\\\\lVert \\\\vec{r_2} - \\\\vec{r_1} \\\\rVert^2} \\\\frac{\\\\vec{r_2} - \\\\vec{r_1}}{\\\\lVert \\\\vec{r_2} - \\\\vec{r_1} \\\\rVert}\\n=\\\\frac{G m_1 m_2 (\\\\vec{r_2} - \\\\vec{r_1})}{\\\\lVert \\\\vec{r_2} - \\\\vec{r_1} \\\\rVert^3}\\n$$\"), mdx(\"p\", null, \"The force of attraction between these two bodies is always on the line between the two bodies and we know that the magnitude of the force acting on each body is the same. Given this we can get the force vector for the force acting on body 2 due to body 1 as the negated version of the force on body 1.\"), mdx(\"p\", null, \"$$\\n\\\\vec{F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{12}} = -\\\\vec{F\"), \"{21}}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"force-on-one-body\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Force on One Body\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#force-on-one-body\",\n    \"aria-label\": \"force on one body permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Now that we know how to determine the gravitational force on a body due to a particular neighboring body, we can extend this to more than 2 bodies. Consider a set of $n$ objects with masses $m_i$ where $i$ ranges from 1 to n. The total gravitational force on a body $i$ is the sum of the gravitational forces due to all other bodies.\"), mdx(\"p\", null, \"$$\\n\\\\vec{F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i} = \\\\sum\"), \"{\\\\substack{j=1 \", \"\\\\\", \" j \\\\neq i}}^n \\\\vec{F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{ij}} =\\n\\\\sum\"), \"{\\\\substack{j=1 \", \"\\\\\", \" j \\\\neq i}}^n \\\\frac{G m_i m_j (\\\\vec{r_j} - \\\\vec{r_i})}{\\\\lVert \\\\vec{r_j} - \\\\vec{r_i} \\\\rVert^3}\\n$$\"), mdx(\"p\", null, \"In plain english, the net force on a particular body is the sum of the force equation evaluated between the body of interest and all \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"other\"), \" bodies. In the equation, the $j \\\\neq i$ is what maintains that we do not calculate the attraction of a body onto itself as a body cannot attract itself and we would be dividing by 0 when calculating the force.\"), mdx(\"h2\", {\n    \"id\": \"acceleration-on-one-body\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Acceleration on One Body\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#acceleration-on-one-body\",\n    \"aria-label\": \"acceleration on one body permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"From the net force it's pretty simple to determine the net acceleration. Using Newton's second law we can add an additional equality to our prior expression. With this we can move around some terms and determine the net acceleration.\"), mdx(\"p\", null, \"$$\\n\\\\vec{F\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i} = m_i \\\\vec{a_i} =\\n\\\\sum\"), \"{\\\\substack{i=1 \", \"\\\\\", \" j \\\\neq i}}^n \\\\frac{G m_i m_j (\\\\vec{r_j} - \\\\vec{r_i})}{\\\\lVert \\\\vec{r_j} - \\\\vec{r_i} \\\\rVert^3}\\n$$\"), mdx(\"p\", null, \"$$\\n\\\\vec{a_i} = \\\\frac{\\\\vec{F_i}}{m_i}\\n$$\"), mdx(\"p\", null, \"We can actually use this to summarize the n-body problem as a system of equations and provide the differential equation that we intend to integrate in a later section.\"), mdx(\"p\", null, \"$$\\nm\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i \\\\vec{a_i} = m_i \\\\frac{d^2 \\\\vec{r_i}}{dt^2} =\\n\\\\sum\"), \"{\\\\substack{i=1 \", \"\\\\\", \" j \\\\neq i}}^n \\\\frac{G m_i m_j (\\\\vec{r_j} - \\\\vec{r_i})}{\\\\lVert \\\\vec{r_j} - \\\\vec{r_i} \\\\rVert^3}\\n$$\"), mdx(\"p\", null, \"Recall from the prior numerical integrator post that we integrated a similar differential equation for a mass-spring system but only in 1 dimension! Something that I find beautiful is that our code extends super well into the higher dimensionality cases. \"), mdx(\"h2\", {\n    \"id\": \"acceleration-for-all-bodies\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Acceleration for All Bodies\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#acceleration-for-all-bodies\",\n    \"aria-label\": \"acceleration for all bodies permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Clearly, we need to evaluate the net acceleration for all the bodies in our system to know how each of them are going to move. The simple way to do this would be evaluate the prior expression for each of the bodies but in practice this is quite inefficient as there's repeated work being done. Let's see why this is the case and how we can improve it.\"), mdx(\"h3\", {\n    \"id\": \"brute-force-method\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Brute Force Method\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#brute-force-method\",\n    \"aria-label\": \"brute force method permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Let's consider computing the attraction force between two bodies as a basic operation. We want to minimize the number of times we have to do this to improve the speed of our code. In this simple case, let's call it the brute force method, we compute the net force for each body as in independent operation. To do so, we need to compute $n-1$ forces for each of the $n$ bodies. Overall the number of force calculations ($K$) scales with the number of bodies quadratically.\"), mdx(\"p\", null, \"$$\\nK= n(n-1)\\n$$\"), mdx(\"p\", null, \"Python pseudocode for this would look something like the following where we can see that compute force would get called $n(n-1)$ times. Don't focus too much on the details of the actual functions or variables but think more about how many times we get to the line where we compute force.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"for i in range(N): # N being number of bodies\\n    for j in range(N): # Neighboring bodies\\n        if i == j: # If it's the same body move on\\n            continue\\n        force[i] += compute_force(i,j) # This is arbitrary\\n\")), mdx(\"h3\", {\n    \"id\": \"combination-method\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Combination Method\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#combination-method\",\n    \"aria-label\": \"combination method permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"In this method, we will try to leverage the property that each force we compute can be negated to provide a second force that we can use. In that case, we can resolve two forces in our sets of forces that we need to calculate and reduce our force calculations by half.\"), mdx(\"p\", null, \"$$\\nK = \\\\frac{n(n-1)}{2}\\n$$\"), mdx(\"p\", null, \"In practice, all this entails is computing the forces for all combinations of bodies! Looking at the equation for number of combinations we can see that this reduces to the prior assertion for operation count. To be precise, we'll be looking at all combinations of size 2 ($r=2$) from the set of all our bodies. I will refer to the set of combinations the pairs of bodies ($P$) throughout the rest of the post.\"), mdx(\"p\", null, \"$$\\nC(n,r) = \\\\frac{n!}{r!(n-r)!}\\n$$\"), mdx(\"p\", null, \"$$\\nC(n,2) = \\\\frac{n!}{2(n-2)!} = \\\\frac{n(n-1)}{2}\\n$$\"), mdx(\"p\", null, \"Python pseudocode for this would look something like the following where we reduce the number of calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"compute_force\"), \". The biggest takeaway here is that by looking at the combinations of bodies we can avoid repeat force calculations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# pairs is the set of combinations of the n bodies\\n# `pairs` looks like [(0,1), (0,2), (1, 2)] in a 3 body case\\nfor i, j in pairs: # Pairs will be n(n-1)/2 in length\\n    F_ij = compute_force(i,j) # Force from i => j\\n    forces[i] += F_ij # Add force to the net force for body i\\n\\n    F_ji = -F_ij # Force from j => i\\n    forces[j] += F_ji # Add force to the net force for body j\\n\")), mdx(\"h3\", {\n    \"id\": \"operation-count-comparison\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Operation Count Comparison\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#operation-count-comparison\",\n    \"aria-label\": \"operation count comparison permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"When comparing the different operation counts as the number of bodies $n$ increases we can see that there is a formidable gain in using the combination method over the brute force method. \"), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/c966caf5c639ec73ed9d3e1317db9100/111a0/force_pair_comp.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3aEUf//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAQEBAQEAAAAAAAAAAAAAAAEAERAh/9oACAEBAAE/IQH17kFl/9oADAMBAAIAAwAAABBjz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQADAQADAAAAAAAAAAAAAAEAESExQVGh/9oACAEBAAE/ECKBb7FPFRNjvqHqJbvyb6z/2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Operation Count Comparison\",\n    \"title\": \"Operation Count Comparison\",\n    \"src\": \"/static/c966caf5c639ec73ed9d3e1317db9100/6c738/force_pair_comp.jpg\",\n    \"srcSet\": [\"/static/c966caf5c639ec73ed9d3e1317db9100/73b64/force_pair_comp.jpg 300w\", \"/static/c966caf5c639ec73ed9d3e1317db9100/3ad8d/force_pair_comp.jpg 600w\", \"/static/c966caf5c639ec73ed9d3e1317db9100/6c738/force_pair_comp.jpg 1200w\", \"/static/c966caf5c639ec73ed9d3e1317db9100/8b34c/force_pair_comp.jpg 1800w\", \"/static/c966caf5c639ec73ed9d3e1317db9100/111a0/force_pair_comp.jpg 2400w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Operation Count Comparison\"), \"\\n  \")), mdx(\"p\", null, \"Those are familiar with big-$O$ notation may have noticed the both the implementations are still quadratic $O(n^2)$ in nature and are therefore the same time complexity. However, if you were to measure the actual runtime we would see a gain. This is an example where trying to compare time complexity to runtime can get messy.\"), mdx(\"h3\", {\n    \"id\": \"runtime-comparison\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Runtime Comparison\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#runtime-comparison\",\n    \"aria-label\": \"runtime comparison permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Like I mentioned before, the time complexity can be a good indicator of how we would expect the runtime to scale but there are some factors in play that can make them different. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In big-$O$ we drop constants and lower order terms\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ex: $O(4n^2 + n - 2)$ = $O(n^2)$\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Constants can be play a large role in runtime (consider $n$ vs $1000n$)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We may adjust an algorithm where each \\\"iteration\\\" takes longer to run\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We reduced iteration count in our case by 50% but each iteration has more work\")))), mdx(\"p\", null, \"Plotting the runtimes of our two different variants we get the following graph.\"), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/9beec7f739d5ef45bc934b966367753d/4284b/time_all.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe5bA0P/xAAXEAADAQAAAAAAAAAAAAAAAAABEBEg/9oACAEBAAEFApcBf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAIDAQAAAAAAAAAAAAAAAAARARBBYf/aAAgBAQABPyHSmsF2kH//2gAMAwEAAgADAAAAEFMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGRABAQEBAQEAAAAAAAAAAAAAAREAMVEh/9oACAEBAAE/EFRUb5uEYvsxwrLXoPDfQyE+cwhv/9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Comparison of Runtimes\",\n    \"title\": \"Comparison of Runtimes\",\n    \"src\": \"/static/9beec7f739d5ef45bc934b966367753d/6c738/time_all.jpg\",\n    \"srcSet\": [\"/static/9beec7f739d5ef45bc934b966367753d/73b64/time_all.jpg 300w\", \"/static/9beec7f739d5ef45bc934b966367753d/3ad8d/time_all.jpg 600w\", \"/static/9beec7f739d5ef45bc934b966367753d/6c738/time_all.jpg 1200w\", \"/static/9beec7f739d5ef45bc934b966367753d/8b34c/time_all.jpg 1800w\", \"/static/9beec7f739d5ef45bc934b966367753d/111a0/time_all.jpg 2400w\", \"/static/9beec7f739d5ef45bc934b966367753d/4284b/time_all.jpg 3000w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Comparison of Runtimes\"), \"\\n  \")), mdx(\"p\", null, \"We can see that when we normalize the time and theoretical iteration count on the brute force method the times line up for the brute force (blue) meaning that the trend $O(n^2)$ is correct. When we look at the combination method what we see is that the runtimes do not follow the expected trend, why is this? In our case, our algo has more work to do per iteration than the brute force method so even though we expect the runtime to be 50% of the brute force we see that it's actually around ~63%.\"), mdx(\"p\", null, \"All of our analysis is still correct but it's important to understand the limitations of big-$O$ in terms of comparing such similar algorithms. If we managed to develop an algorithm that ran in $O(n)$ time complexity we would not be nearly as concerned about what the true value of the constants are.\"), mdx(\"h1\", {\n    \"id\": \"system-energies\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"System Energies\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#system-energies\",\n    \"aria-label\": \"system energies permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Clearly the system starts with a set amount of energy based on the positions, masses, and velocities that manifest as kinetic energy and potential energy. We don't need to compute these to execute a simulation but as we expect the system to maintain energy this can be a good check to see how we're doing.\"), mdx(\"h2\", {\n    \"id\": \"kinetic-energy\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Kinetic Energy\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#kinetic-energy\",\n    \"aria-label\": \"kinetic energy permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Kinetic is really easy! We just need to sum up the result of a classic physics equation.\"), mdx(\"p\", null, \"$$\\n\\\\text{KE} = \\\\sum\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{i=1}^n\\\\frac{1}{2}m_i v_i^2 = \\\\sum\"), \"{i=1}^n\\\\frac{1}{2}m_i \\\\lVert \\\\vec{v_i} \\\\rVert^2\\n$$\"), mdx(\"h2\", {\n    \"id\": \"potential-energy\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Potential Energy\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#potential-energy\",\n    \"aria-label\": \"potential energy permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://hyperphysics.phy-astr.gsu.edu/hbase/gpot.html\",\n    \"target\": \"_self\",\n    \"rel\": \"nofollow\"\n  }, \"gravitational potential energy\"), \" $U$ between two objects is something that is really familiar! Just as we're only looking at the combinations of bodies to determine our forces we will do the same here where $i$ and $j$ will be the indices for our bodies out of our set of combinations ($P$).\"), mdx(\"p\", null, \"$$\\nU(r) = \\\\frac{-Gm_1m_2}{r}\\n$$\"), mdx(\"p\", null, \"$$\\n\\\\text{PE} =\\n\\\\sum\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{i,j \\\\in P} \\\\frac{-Gm_im_j}{r\"), \"{ij}} =\\n\\\\sum_{i,j \\\\in P} \\\\frac{-Gm_im_j}{\\\\lVert \\\\vec{r_j} - \\\\vec{r_i} \\\\rVert}\\n$$\"), mdx(\"h1\", {\n    \"id\": \"system-state\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"System State\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#system-state\",\n    \"aria-label\": \"system state permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I have been throwing around the word state a bit loosely, let's try to refine our understanding of what this means and why it's useful for us. The 30 second answer is that a state is a matrix that maintains all of the important values that describe the aspects of our system such as the positions and velocities of all of our objects.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"States are a joint representation of everything going on in our system. They help us simplify our integration operations and keep track of our variables.\")), mdx(\"h2\", {\n    \"id\": \"structure\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Structure\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#structure\",\n    \"aria-label\": \"structure permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"As I mentioned, a state is merely a matrix but the structure of how its constructed and what it contains is the important part. For our physical modeling cases, the state will contain the position and velocities of all the objects where each row is the state of one object and each column is a variable of importance (think a certain position/velocity).\"), mdx(\"p\", null, \"$$\\nX =\\n\\\\begin{bmatrix}\\nX_1\", \"\\\\\", \"\\nX_2\", \"\\\\\", \"\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n\\\\vec{r_1} & \\\\vec{v_1} \", \"\\\\\", \"\\n\\\\vec{r_2} & \\\\vec{v_2}\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n{x_1} & {y_1} & \\\\dot{x_1} & \\\\dot{y_1}\", \"\\\\\", \"\\n{x_2} & {y_2} & \\\\dot{x_2} & \\\\dot{y_2}\", \"\\\\\", \"\\n\\\\end{bmatrix}\\n$$\"), mdx(\"p\", null, \"The prior would be the state for a 2D case with two objects. Don't confuse $X$ with $x$, the capital $X$ is the state and has nothing to do with the position variable $x$.\"), mdx(\"h2\", {\n    \"id\": \"state-derivative\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"State Derivative\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#state-derivative\",\n    \"aria-label\": \"state derivative permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Along with the state, there is a accompanying state derivative $\\\\dot{X}$, it might sound scary but it isn't. Throughout the integration process we make incremental changes to the state, but doing so for each value independently would be annoying and inefficient. The state derivative is a way to encode the corresponding derivative for each of the values in the state so that when we need to do update steps we can proceed with them as matrix sums. For our purposes, the structure would look like the below for the same case as before.\"), mdx(\"p\", null, \"$$\\n\\\\dot{X} =\\n\\\\begin{bmatrix}\\n\\\\dot{X_1}\", \"\\\\\", \"\\n\\\\dot{X_2}\", \"\\\\\", \"\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n\\\\dot{\\\\vec{r_1}} & \\\\dot{\\\\vec{v_1}} \", \"\\\\\", \"\\n\\\\dot{\\\\vec{r_2}} & \\\\dot{\\\\vec{v_2}}\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n\\\\dot{x_1} & \\\\dot{y_1} & \\\\ddot{x_1} & \\\\ddot{y_1}\", \"\\\\\", \"\\n\\\\dot{x_2} & \\\\dot{y_2} & \\\\ddot{x_2} & \\\\ddot{y_2}\", \"\\\\\", \"\\n\\\\end{bmatrix}\\n$$\"), mdx(\"h2\", {\n    \"id\": \"advantages\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Advantages\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#advantages\",\n    \"aria-label\": \"advantages permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For simple systems, it might be easier to just build out a numerical integrator for each of the variables of interest, but for large n-body systems this would get messy quickly. Consider an example in 3D with 50 bodies, this would mean that we have 300 variables of interest and therefore 300 integrators! When we represent this system in the state matrix form, there are still the 300 values being updated but it's reduced to a series of sums between the entire matrices which is much cleaner (and can be \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html\",\n    \"target\": \"_self\",\n    \"rel\": \"nofollow\"\n  }, \"vectorized\"), \").\"), mdx(\"h2\", {\n    \"id\": \"simple-example\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Simple Example\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#simple-example\",\n    \"aria-label\": \"simple example permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Let's do a simple two-body example in 2D to see how this is going to play out in our code! Let's consider two bodies with the properties in the below table.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Body\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Position $\\\\vec{r}$\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Velocity $\\\\vec{v}$\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle 0, 0 \\\\rangle$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle 5, 2 \\\\rangle$\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle 2, 0 \\\\rangle$\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"$\\\\langle 2, 1 \\\\rangle$\")))), mdx(\"h3\", {\n    \"id\": \"state-representation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"State Representation\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#state-representation\",\n    \"aria-label\": \"state representation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"If we follow the general structure shown before it's quite evident how this would be constructed. Recall that each row contains the variables needed to describe a single object's condition in our system.\"), mdx(\"p\", null, \"$$\\nX =\\n\\\\begin{bmatrix}\\nX_1\", \"\\\\\", \"\\nX_2\", \"\\\\\", \"\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n\\\\vec{r_1} & \\\\vec{v_1} \", \"\\\\\", \"\\n\\\\vec{r_2} & \\\\vec{v_2}\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n0 & 0 & 5 & 2 \", \"\\\\\", \"\\n2 & 0 & 2 & 1 \", \"\\\\\", \"\\n\\\\end{bmatrix}\\n$$\"), mdx(\"h3\", {\n    \"id\": \"state-derivative-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"State Derivative\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#state-derivative-1\",\n    \"aria-label\": \"state derivative 1 permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The goal is to fill out the prior structure which requires us to compute the acceleration on each body. Let's assume that the only force involved in this case is the gravitational attraction between the bodies, for the sake of cleaner math let's assume $G=1$ and that the masses are both $1$.\"), mdx(\"p\", null, \"$$\\n\\\\vec{F_{12}} = \\\\frac{G m_1 m_2 (\\\\vec{r_2} - \\\\vec{r_1})}{\\\\lVert \\\\vec{r_2} - \\\\vec{r_1} \\\\rVert^3} =\\n\\\\frac{(\\\\vec{r_2} - \\\\vec{r_1})}{\\\\lVert \\\\vec{r_2} - \\\\vec{r_1} \\\\rVert^3}\\n$$\"), mdx(\"p\", null, \"$$\\n=\\\\frac{\\\\langle 2, 0 \\\\rangle}{8}\\n$$\"), mdx(\"p\", null, \"We know from before that the force for the other body in the force pair is just the negated version of this force so we can also compute the force for body 1.\\n$$\\n\\\\vec{F_{21}}=-\\\\frac{\\\\langle 2, 0 \\\\rangle}{8}\\n$$\"), mdx(\"p\", null, \"As the masses are just 1, the value of the acceleration and the force are the same so we can go ahead and fill out the state derivative.\"), mdx(\"p\", null, \"$$\\n\\\\dot{X} =\\n\\\\begin{bmatrix}\\n\\\\dot{X_1}\", \"\\\\\", \"\\n\\\\dot{X_2}\", \"\\\\\", \"\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n\\\\dot{\\\\vec{r_1}} & \\\\dot{\\\\vec{v_1}} \", \"\\\\\", \"\\n\\\\dot{\\\\vec{r_2}} & \\\\dot{\\\\vec{v_2}}\\n\\\\end{bmatrix}\\n$$\\n$$\\n=\\\\begin{bmatrix}\\n\\\\vec{v_1} & \\\\vec{a_1} \", \"\\\\\", \"\\n\\\\vec{v_2} & \\\\vec{a_2}\\n\\\\end{bmatrix} =\\n\\\\begin{bmatrix}\\n5 & 2 & 0.25 & 0\", \"\\\\\", \"\\n2 & 1 & -0.25 & 0\", \"\\\\\", \"\\n\\\\end{bmatrix}\\n$$\"), mdx(\"h3\", {\n    \"id\": \"example-euler-integration-step\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Example Euler Integration Step\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#example-euler-integration-step\",\n    \"aria-label\": \"example euler integration step permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Now that we have the state and the state derivative, we can actually proceed with doing a simple Euler integration step. Let's consider a step size of $h=1$, we can compute the new state with the following.\"), mdx(\"p\", null, \"$$\\nX_1 = X_0 + h \\\\dot{X_0}\\n$$\"), mdx(\"p\", null, \"$$\\nX_1 =\\n\\\\begin{bmatrix}\\n0 & 0 & 5 & 2 \", \"\\\\\", \"\\n2 & 0 & 2 & 1 \", \"\\\\\", \"\\n\\\\end{bmatrix}\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1\\n\\\\begin{bmatrix}\\n5 & 2 & 0.25 & 0\", \"\\\\\", \"\\n2 & 1 & -0.25 & 0\", \"\\\\\", \"\\n\\\\end{bmatrix}\\n$$\")), mdx(\"p\", null, \"$$\\nX_1 =\\n\\\\begin{bmatrix}\\n5 & 2 & 5.25 & 2 \", \"\\\\\", \"\\n4 & 1 & 1.75 & 1 \", \"\\\\\", \"\\n\\\\end{bmatrix}\\n$$\"), mdx(\"p\", null, \"In this post, we will be using a better integrator then Euler, but this simple example presents the core workflow of how we will represent our system and the role that the state derivative plays in propagating the state forward.\"), mdx(\"h1\", {\n    \"id\": \"integrator-refresher\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Integrator Refresher\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#integrator-refresher\",\n    \"aria-label\": \"integrator refresher permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Although it helps to have read my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/integrator-intro/\"\n  }, \"post\"), \" on integrators already, I'll do a short summary of the usage of the RK4 integrator that we are using in this post. If you are already comfortable doing the example cases from that post you can skip ahead, but I would recommend you read regardless as I also wrote this example as a precursor to the later structure.\"), mdx(\"h2\", {\n    \"id\": \"general-form\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"General Form\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#general-form\",\n    \"aria-label\": \"general form permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The basic form of the RK4 integrator for a given state $X$ is as follows. The integrator will estimate what the new state $X_{i+1}$ will be one $h$ later (in our case our unit is time so this would be a timestep). In simpler terms, given the values of our system at a time, we can use the integrator to see how these values would change if we progress one timestep into the future.\"), mdx(\"p\", null, \"$$\\nk_1 = h \\\\, \\\\dot{X}(X_i)\\n$$\"), mdx(\"p\", null, \"$$\\nk_2 = h \\\\, \\\\dot{X}(X_i + 0.5 \\\\times k_1)\\n$$\"), mdx(\"p\", null, \"$$\\nk_3 = h \\\\, \\\\dot{X}(X_i + 0.5 \\\\times k_2)\\n$$\"), mdx(\"p\", null, \"$$\\nk_4 = h \\\\, \\\\dot{X}(X_i + k_3)\\n$$\"), mdx(\"p\", null, \"$$\\nX_{i+1} = X_i + \\\\frac{1}{6} (k_1 + 2k_2 + 2k_3 + k4)\\n$$\"), mdx(\"p\", null, \"This is best defined as a function in code as follows.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def rk4(X, dt, evaluate):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - X: Current state of system\\n    - dt: Integration Timestep\\n    - evaluate: Function that will return the derivative for the state\\n    Returns:\\n    - X: Updated state one timestep later\\n    \\\"\\\"\\\"\\n    # Calculate Terms\\n    k1 = evaluate(X)\\n    k2 = evaluate(X + 0.5*k1*dt)\\n    k3 = evaluate(X + 0.5*k2*dt)\\n    k4 = evaluate(X + k3*dt)\\n\\n    # Update X\\n    X_prime = (1/6.)*(k1 + 2*k2 + 2*k3 + k4)\\n    return X + X_prime * dt\\n\")), mdx(\"h2\", {\n    \"id\": \"mass-spring-system\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Mass-Spring System\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#mass-spring-system\",\n    \"aria-label\": \"mass spring system permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Let's go ahead and consider a simple differential equation for a mass and spring system with no damping. Note that the smaller $x$ in this equation is not a state but just a single variable. \"), mdx(\"p\", null, \"$$\\nm \\\\ddot{x} + k x = 0 \\\\rightarrow m \\\\ddot{x} = -kx\\n$$\"), mdx(\"p\", null, \"Our initial conditions for the system will be the position $x$ and velocity $\\\\dot{x}$ at $t=0$. The state and the corresponding state derivative would be the following.\"), mdx(\"p\", null, \"$$\\nX = \\\\begin{bmatrix}x & \\\\dot{x}\\\\end{bmatrix} \\\\quad \\\\dot{X} = \\\\begin{bmatrix}\\\\dot{x} & \\\\ddot{x}\\\\end{bmatrix}\\n$$\"), mdx(\"p\", null, \"Let's go ahead and write our differential equation into a function that will return the state derivative for a given state. In general, when your system of equations changes this will manifest as a change to the function that returns the state derivative. For example, if this system also had a damper we would have to include the changes to the ODE in the calculation for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"xdd\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def get_state_deriv(X):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - X: State matrix with position and velocity\\n    Returns:\\n    - Xdot: State derivative matrix to be used in integration \\n    \\\"\\\"\\\"\\n    # ODE Constants \\n    m, k = 1, 1\\n\\n    # Build State Derivative\\n    xdd = -(k/m) * X[0] # x double dot from ODE\\n    Xdot = np.array([X[1], xdd])\\n    return Xdot\\n\")), mdx(\"p\", null, \"We can now execute a simple simulation and plot the results against the known solution to this which is $\\\\sin(t)$ for these constants.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Imports\\nimport copy\\nfrom math import ceil\\nimport numpy as np\\nimport matplotlib.pyplot as plt\\n\\n# Initial conditions\\nXi = np.array([1,0]) # [x, xdot] => [Initial Position=1, Initial Velocity=0]\\nT, dt = 10, 0.25\\niters = ceil(T / dt) # Number of iterations\\n\\n# Init History to Store Results\\nhistory = np.zeros((iters+1, 2))\\nhistory[0] = Xi\\ntimes = np.linspace(0, T, iters+1)\\n\\n# Execute the Simulation\\nX = copy.deepcopy(Xi)\\nfor i in range(iters):\\n    history[i+1] = rk4(history[i], dt, get_state_deriv)\\n\\nplt.plot(times, np.cos(times), color='gray', linestyle='dashed', label='True')\\nplt.scatter(times, history[:,0], color='blue', s=20, label='Simulated')\\nplt.xlabel(\\\"Time (s)\\\")\\nplt.ylabel(\\\"Mass Position (m)\\\")\\nplt.legend()\\nplt.show()\\n\")), mdx(\"p\", null, \"This should yield the following plot where we can see that the simulated points match up with the true result quite well! \"), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/9025a9398fd0271e2eae81ae3e10c740/111a0/mass_spring_test.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3VAmP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAAMBAQAAAAAAAAAAAAAAAAABERBR/9oACAEBAAE/IV3IiZD/2gAMAwEAAgADAAAAENPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFBUf/aAAgBAQABPxDbY29iCrXORDhk9b2AmXK/Wf/Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Mass Spring Position\",\n    \"title\": \"Mass Spring Position\",\n    \"src\": \"/static/9025a9398fd0271e2eae81ae3e10c740/6c738/mass_spring_test.jpg\",\n    \"srcSet\": [\"/static/9025a9398fd0271e2eae81ae3e10c740/73b64/mass_spring_test.jpg 300w\", \"/static/9025a9398fd0271e2eae81ae3e10c740/3ad8d/mass_spring_test.jpg 600w\", \"/static/9025a9398fd0271e2eae81ae3e10c740/6c738/mass_spring_test.jpg 1200w\", \"/static/9025a9398fd0271e2eae81ae3e10c740/8b34c/mass_spring_test.jpg 1800w\", \"/static/9025a9398fd0271e2eae81ae3e10c740/111a0/mass_spring_test.jpg 2400w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Mass Spring Position\"), \"\\n  \")), mdx(\"p\", null, \"I point out this example because the form of the ODE is more similar to the n-body problem then you may have thought. The prior formulation of the state and state derivative are very similar to what we do for the n-body case.\"), mdx(\"p\", null, \"$$\\nm \\\\ddot{x} = -kx\\n$$\"), mdx(\"p\", null, \"$$\\nm\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"i \\\\vec{a_i} =\\n\\\\sum\"), \"{\\\\substack{i=1 \", \"\\\\\", \" j \\\\neq i}}^n \\\\frac{G m_i m_j (\\\\vec{r_j} - \\\\vec{r_i})}{\\\\lVert \\\\vec{r_j} - \\\\vec{r_i} \\\\rVert^3}\\n$$\"), mdx(\"h1\", {\n    \"id\": \"executing-a-simulation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Executing a Simulation\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#executing-a-simulation\",\n    \"aria-label\": \"executing a simulation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The last step before we can move onto the implementation is just seeing how we stack up all of our prior operations to actually run a simulation.\"), mdx(\"h2\", {\n    \"id\": \"number-of-iterations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Number of Iterations\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#number-of-iterations\",\n    \"aria-label\": \"number of iterations permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The first step is to determine how many simulation steps we're going to be taking. This is trivially done with the given end time $T$ and the time step $dt$. We use the ceiling function here to run a simulation slightly longer than needed as opposed to too short.\"), mdx(\"p\", null, \"$$\\n\\\\text{Iterations} = \\\\lceil \\\\frac{T}{dt} \\\\rceil\\n$$\"), mdx(\"h2\", {\n    \"id\": \"initializations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Initializations\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#initializations\",\n    \"aria-label\": \"initializations permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"We have a few additional initializations that make sense to run here and not in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \".\"), mdx(\"h3\", {\n    \"id\": \"history\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"History\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#history\",\n    \"aria-label\": \"history permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"We'll store the history of the states in one large \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"history\"), \" matrix of size \", \"[Iterations +1, N, D]\", \". Essentially it's a stack of (Iterations + 1) states indexed by the simulation iteration.\"), mdx(\"h3\", {\n    \"id\": \"body-pairs\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Body Pairs\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#body-pairs\",\n    \"aria-label\": \"body pairs permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Across multiple different operations we utilize the sets of body pairs based on the combination. It's helpful to pre compute them so that it's not a repeated operation.\"), mdx(\"h3\", {\n    \"id\": \"energies\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Energies\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#energies\",\n    \"aria-label\": \"energies permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Similarly to the state history, we'll initialize a history of energies of size \", \"[Iterations + 1, 3]\", \" as we store kinetic, potential, and total energy. This step is done after the body pairs as the energy calculations depend on the pairs.\"), mdx(\"h2\", {\n    \"id\": \"running-iterations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Running Iterations\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#running-iterations\",\n    \"aria-label\": \"running iterations permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"We now have everything we need to execute a simulation! All we do now is call our integrator function to step the state ahead by on timestep and save the new state into our history. Along the way we also compute the energy for each of these new states and store that too.\"), mdx(\"h1\", {\n    \"id\": \"implementation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Implementation\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#implementation\",\n    \"aria-label\": \"implementation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Time for the fun stuff, in this section we'll go over how to take these concepts and implement them in Python. Let's go ahead and start with importing the Python modules that we intend to use.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import copy # Used for creating non-linked copies of states\\nfrom math import ceil # Helpful for rounding off floats to conservative ceilings\\nfrom itertools import combinations # Produces the sets of combinations for pairs\\nimport numpy as np # General matrix compute platform\\nimport matplotlib.pyplot as plt # Used for plotting and analysis\\n\")), mdx(\"h2\", {\n    \"id\": \"simulation-class\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Simulation Class\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#simulation-class\",\n    \"aria-label\": \"simulation class permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Many of the operations and variables we use are reused across the simulation, so it helps to encapsulate it all into a class to clean up many of the references. Below is the framework that we'll fill out in the later steps, so if you want to follow along go ahead and copy this before we start.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class NBody:\\n    def __init__(self, Xi=None, masses=None, G=6.67408e-11):\\n        pass\\n    \\n    def get_energy(self, X):\\n        pass\\n    \\n    def get_state_deriv(self, X):\\n        pass\\n        \\n    def rk4(self, X, dt, evaluate):\\n        pass\\n    \\n    def run_simulation(self, T, dt):\\n        pass\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"init\"), \": Initializes some of the reused variables across our class\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"get_energy\"), \": Returns the kinetic and potential energy of the system at a given state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"get_state_deriv\"), \": Determines the state derivative of a given state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rk4\"), \": Integrates the input state to a new state one timestep ahead\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"run_simulation\"), \": Calls all requisite functions to produce a sequence of states up to a time T\")), mdx(\"p\", null, \"The main benefit of doing this as a class is that we can provide instances for different types of simulations or different initial conditions. Also there are many variables that are static and used by different functions so this reduces the amount of repeat work (think about how many times we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self.pairs\"), \").\"), mdx(\"h2\", {\n    \"id\": \"init\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Init\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#init\",\n    \"aria-label\": \"init permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Some of this may not be immediately clear but you'll see why we're doing this as we develop more of the core functions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def __init__(self, Xi=None, masses=None, G=6.67408e-11):\\n\\n    # Init State and Masses\\n    self.Xi = Xi # Set the initial state matrix\\n    self.masses = masses # Set the body masses array\\n    \\n    # Set gravitational constant\\n    # This really shouldn't change but it's fun for some special cases\\n    self.G = G\\n    \\n    # History is where we'll store the results of the simulation\\n    # We will not define a history without a sim so it's none for now\\n    self.history = None\\n    self.energies = None\\n\")), mdx(\"h2\", {\n    \"id\": \"system-energy\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"System Energy\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#system-energy\",\n    \"aria-label\": \"system energy permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The prior formulations maps really well into the code! While there are faster ways to compute these by using vectorization and maintaining matrices as opposed to iterating but this is way easier to understand which is why I opted to present it this way.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def get_energy(self, X):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - X: The current state to determine the energy for\\n    - masses: Array of masses corresponding to the bodies\\n    - G: Gravitational constant, needed for potential energy\\n    Returns:\\n    - KE: Total kinetic energy of the system in joules\\n    - PE: Total potential energy of the system in joules\\n    \\\"\\\"\\\"\\n\\n    # Useful Variables\\n    N, D = X.shape # Get the number of bodies, and dimensionality\\n    D = D // 2 # Get the number of dimensions, are we 2d or 3d?\\n    R = X[:, :D] # Submatrix with all positions\\n    V = X[:, D:] # Submatrix with all velocities\\n\\n    # Determine Kinetic Energy\\n    # 1/2 * mass * v ^ 2\\n    KE = 0\\n    for i in range(N):\\n        KE += 0.5 * self.masses[i] * np.linalg.norm(V[i]) ** 2\\n\\n    # Determine Potential Energy\\n    # (-G * m_i * m_j) / r_ij\\n    PE = 0\\n    for body_i, body_j in self.pairs:\\n        r = np.linalg.norm(R[body_j] - R[body_i]) # Distance between bodies\\n        PE -= self.masses[body_i] * self.masses[body_j] / r\\n    PE *= self.G # Multiplying is expensive so I only do one at the end\\n\\n    return KE, PE\\n\")), mdx(\"h2\", {\n    \"id\": \"state-derivative-2\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"State Derivative\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#state-derivative-2\",\n    \"aria-label\": \"state derivative 2 permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Take some time to really understand this section as it's the meat of the conversation today. I personally think it's much easier to understand what is happening when looking at the code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def get_state_deriv(self, X):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - X: The current state to determine the state derivative for\\n    Returns:\\n    - Xdot: The corresponding state derivative for the input state\\n    \\\"\\\"\\\"\\n    \\n    # Useful Variables\\n    N, D = X.shape # Get the number of bodies, and dimensionality\\n    D = D // 2 # Get the number of dimensions, are we 2d or 3d?\\n    R = X[:, :D] # Submatrix with all positions\\n    V = X[:, D:] # Submatrix with all velocities\\n\\n    # Build Placeholder Structure\\n    Xdot = np.zeros_like(X) # Xdot is the same size as X\\n    Xdot[:, :D] = V # Fill in velocities from state \\n\\n    # Iterate Over Pairs and Fill Out Acceleration\\n    # self.pairs gets defined when we start a sim\\n    # body_i, body_j are the indices of the bodies\\n    for body_i, body_j in self.pairs:\\n\\n        # Get vector from body_i => body_j and its magnitude\\n        r1, r2 = R[body_i], R[body_j] # Positions of body_i and body_j\\n        r_vec = r2 - r1 # Vector from body_i => body_j\\n        r = np.linalg.norm(r_vec) # Distance from body_i => body_j\\n\\n        # Find Force from body_i => body_j\\n        F = self.G * self.masses[body_i] * self.masses[body_j] * r_vec / r**3\\n        a1 =  F / self.masses[body_i] # Compute acceleration for body_i\\n        a2 = -F / self.masses[body_j] # Compute acceleration for body_j\\n\\n        # Apply acceleration to body_i and body_j\\n        Xdot[body_i, D:] += a1\\n        Xdot[body_j, D:] += a2\\n\\n    return Xdot\\n\")), mdx(\"h2\", {\n    \"id\": \"rk4-integrator\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"RK4 Integrator\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#rk4-integrator\",\n    \"aria-label\": \"rk4 integrator permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This is a direct copy from my prior work. The purpose of the integrator is to take in a current state and advance the state to where it should be one timestep (dt) later. This of course relies on being able to compute the state derivative which is what the function we pass in as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"evaluate\"), \" is needed for.\"), mdx(\"p\", null, \"Generally speaking, the RK4 integrator is a good all-around integrator for various types of problems (to me it's reliable but likely not optimal depending on the case). As an example, when simulating Hamiltonian systems (often called conservative systems) one can use special integrators that preserve the constant energy nature of these systems. I won't get into it here, but I'm just trying to imply that there isn't one \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"best\"), \" integrator.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def rk4(self, X, dt, evaluate):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - X: Current state of system\\n    - dt: Integration Timestep\\n    - evaluate: Function that will return the derivative for the state\\n    Returns:\\n    - X: Updated state one timestep later\\n    \\\"\\\"\\\"\\n    # Calculate Terms\\n    k1 = evaluate(X)\\n    k2 = evaluate(X + 0.5*k1*dt)\\n    k3 = evaluate(X + 0.5*k2*dt)\\n    k4 = evaluate(X + k3*dt)\\n\\n    # Update X\\n    X_prime = (1/6.)*(k1 + 2*k2 + 2*k3 + k4)\\n    return X + X_prime * dt\\n\")), mdx(\"h2\", {\n    \"id\": \"running-the-simulation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Running the Simulation\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#running-the-simulation\",\n    \"aria-label\": \"running the simulation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Now that we have all the requisite functions defined, we can go ahead and piece it together here in the main simulation call. As we are using a class to hold all of our information, I added some assertions to the start to ensure we have the required arguments to execute a simulation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def run_simulation(self, T, dt):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - T: Total runtime of simulation\\n    - dt: Timestep for integration\\n    Returns:\\n    - history: Matrix of the history of states\\n    \\\"\\\"\\\"\\n    \\n    # Check to ensure initial conditions and masses have been set\\n    assert self.Xi is not None\\n    assert self.masses is not None\\n    \\n    # Setup Sim Params\\n    iters = ceil(T / dt) # Number of simulation iterations\\n    \\n    # Init History\\n    N, D = self.Xi.shape\\n    self.history = np.zeros((iters+1, N, D))\\n    self.history[0] = self.Xi # First history is our initial conditions\\n\\n    # Determine Force Pair Indexes\\n    self.pairs = list(combinations(range(N), 2))\\n\\n    # Init Energies\\n    self.energies = np.zeros((iters+1, 3))\\n    KE, PE = self.get_energy(self.Xi)\\n    self.energies[0] = np.array([KE, PE, KE+PE])\\n    \\n    # Run Simulation Iterations\\n    X = copy.deepcopy(self.Xi) # Copy as to not modify Xi\\n    for i in range(iters):\\n        X = self.rk4(X, dt, self.get_state_deriv) # Get new state\\n        self.history[i+1] = X # Store new state\\n        KE, PE = self.get_energy(X) # Get new state's energy \\n        self.energies[i+1] = np.array([KE, PE, KE+PE]) # Store energy\\n    return self.history\\n\")), mdx(\"h1\", {\n    \"id\": \"simple-two-body--verification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Simple Two Body & Verification\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#simple-two-body--verification\",\n    \"aria-label\": \"simple two body  verification permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Before we step into larger and more interesting examples, it helps to validate that the work that we did is providing results that we think are correct. Let's consider a simple case of a small satellite orbiting in a circular low earth orbit (LEO), akin to a Starlink satellite.\"), mdx(\"h2\", {\n    \"id\": \"initial-conditions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Initial Conditions\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#initial-conditions\",\n    \"aria-label\": \"initial conditions permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For this simple case we can make a useful function to help us determine what the initial conditions would be for a circular orbit. When an object is orbiting a body, there is a balancing act between the centripetal force and gravitational force. A circular orbit is constantly in this balance, so we can set the force equal to each other and solve for the needed velocity for a given input radius.\"), mdx(\"p\", null, \"$$\\nF_c = F_g \\\\rightarrow \\\\frac{m_1v^2}{r} = \\\\frac{Gm_1m_2}{r^2}\\n$$\"), mdx(\"p\", null, \"$$\\nv^2 = \\\\frac{Gm_2}{r}\\n$$\"), mdx(\"p\", null, \"$$\\nv = \\\\sqrt{\\\\frac{Gm_2}{r}}\\n$$\"), mdx(\"p\", null, \"Where $m_2$ is the mass of the body that our satellite is orbiting. Generalizing this for a satellite orbiting earth we can make a helpful function for setting up initial conditions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def earth_stable_orbit(r):\\n    \\\"\\\"\\\"\\n    Inputs:\\n    - r: Altitude of orbit above earth's surface in meters\\n    Returns:\\n    - v: Velocity in m/s to sustain a stable circular orbit\\n    \\\"\\\"\\\"\\n    G = 6.67408e-11\\n    massE = 5.974e24 # Mass in kg\\n    rE = 6.3781e6 # Radius in m\\n    return np.sqrt(G * massE / (r + rE))\\n\")), mdx(\"p\", null, \"With this function we can easily define our initial conditions in terms of an orbital altitude. The first body in our state is the earth at origin not moving (hence $\\\\langle 0,0,0,0\\\\rangle$) and the second body is our satellite.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"massE, rE = 5.974e24, 6.3781e6 # Earth properties\\nr = 760e3 # Satellite Orbit Altitude\\n\\n# Setting up initial state\\nX = np.array([[0, 0, 0, 0],\\n              [rE + r, 0, 0, earth_stable_orbit(r)]])\\nmasses = [massE, 250] # Earth and Small Sat\\n\")), mdx(\"h2\", {\n    \"id\": \"running-simulation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Running Simulation\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#running-simulation\",\n    \"aria-label\": \"running simulation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Now that we have the initial conditions and masses arranged, we can go ahead and initialize an instance of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NBody\"), \" class and call a simulation. In this case given the expected period of the orbit, I opted for a 500 minute end time at a 1 second timestep to get a few periods without an excessive runtime.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"TwoBody = NBody(Xi=X, masses=masses) # Initialize sim instance\\nT, dt =  500 * 60, 1 # Simulation for 500 minutes at a 1 second timestep\\nhistory = TwoBody.run_simulation(T, dt) # Run the sim and get history\\n\")), mdx(\"p\", null, \"Now that we have the simulation history, we can go ahead and plot the example with the following code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Positions for Plotting Earth Circle\\ntheta = np.linspace(0, 2 * np.pi, 150)\\nx = rE * np.cos(theta)\\ny = rE * np.sin(theta)\\n\\n# Plot Earth Surface\\nplt.plot(x, y, label=\\\"Earth Surface\\\", linestyle='dashed')\\n\\n# Plot the satellite orbit\\nx = history[:, 1, 0] # [all sim steps, body 1, first variable in state]\\ny = history[:, 1, 1] # [all sim steps, body 1, second variable in state]\\nplt.plot(x, y, label=\\\"Low Earth Orbit\\\", linewidth=1)\\nplt.axis('equal')\\nplt.legend(loc='upper right')\\nplt.xlabel(\\\"X\\\")\\nplt.ylabel(\\\"Y\\\")\\nplt.show()\\n\")), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/52de19d857fd91fcdd548bbc1b914ed4/9bea7/twobody_orbits.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"100%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe8UyDUAD//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEAAQUCH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABoQAAICAwAAAAAAAAAAAAAAAAAREEEBMWH/2gAIAQEAAT8hsXTVlxkQo//aAAwDAQACAAMAAAAQ8McA/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHRABAAICAgMAAAAAAAAAAAAAAQARIXExQVFhkf/aAAgBAQABPxCrXmNzCHcBFWdwwnqWTluI9wN9/YmWf//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Satellite Orbiting Earth\",\n    \"title\": \"Satellite Orbiting Earth\",\n    \"src\": \"/static/52de19d857fd91fcdd548bbc1b914ed4/6c738/twobody_orbits.jpg\",\n    \"srcSet\": [\"/static/52de19d857fd91fcdd548bbc1b914ed4/73b64/twobody_orbits.jpg 300w\", \"/static/52de19d857fd91fcdd548bbc1b914ed4/3ad8d/twobody_orbits.jpg 600w\", \"/static/52de19d857fd91fcdd548bbc1b914ed4/6c738/twobody_orbits.jpg 1200w\", \"/static/52de19d857fd91fcdd548bbc1b914ed4/8b34c/twobody_orbits.jpg 1800w\", \"/static/52de19d857fd91fcdd548bbc1b914ed4/9bea7/twobody_orbits.jpg 2000w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Satellite Orbiting Earth\"), \"\\n  \")), mdx(\"h2\", {\n    \"id\": \"validation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Validation\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#validation\",\n    \"aria-label\": \"validation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Looks great! Let's dive a bit deeper and verify the orbital period and system energy. Let's consider some simple checks to see if the integrator is performing as we'd expect.\"), mdx(\"h3\", {\n    \"id\": \"orbital-period\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Orbital Period\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#orbital-period\",\n    \"aria-label\": \"orbital period permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For the period evaluation we can make a pretty simple plot to give us confidence that this works. First, let's determine what the period is supposed to be by computing how long it would take to traverse a circle with a radius of our orbit when traveling at our initial velocity. Then we can plot how far the satellite is from the initial position, this way when we return back to where we started we'll see a minimum in our graph that should reflect a period.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python{out={2}}\"\n  }, \"# Compute Expected Period\\n# (2 * pi * r) / v\\nP = 2 * np.pi * TwoBody.Xi[1,0] / TwoBody.Xi[1,3] / 60\\nprint(f\\\"Expected Orbital Period: {P:0.3f} mins\\\")\\n\\n# Get Distance From Initial Conditions\\niters = history.shape[0]\\ntimes = [i * dt / 60 for i in range(iters)]\\ndists = [np.linalg.norm(history[i,1,:2] - history[0,1,:2]) for i in range(iters)]\\n\\n# Plot Dists and Periods\\nplt.vlines(P * np.arange(0,6), 0, max(dists), color='red', linestyle='dashed')\\nplt.plot(times, dists)\\nplt.xlabel(\\\"Time (Mins)\\\")\\nplt.ylabel(\\\"Distance from Init\\\")\\nplt.show()\\n\\nExpected Orbital Period: 100.017 mins\\n\")), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/48ee45f47e226d1fe59a8baa6834b6ca/111a0/period_compare.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3VEUf//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABYQAQEBAAAAAAAAAAAAAAAAAAAREP/aAAgBAQABPyHYiP/aAAwDAQACAAMAAAAQIN//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhMUFRYXH/2gAIAQEAAT8QBdnZmn0TCLU97cGYdIjHMLluf//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Evaluation of Period\",\n    \"title\": \"Evaluation of Period\",\n    \"src\": \"/static/48ee45f47e226d1fe59a8baa6834b6ca/6c738/period_compare.jpg\",\n    \"srcSet\": [\"/static/48ee45f47e226d1fe59a8baa6834b6ca/73b64/period_compare.jpg 300w\", \"/static/48ee45f47e226d1fe59a8baa6834b6ca/3ad8d/period_compare.jpg 600w\", \"/static/48ee45f47e226d1fe59a8baa6834b6ca/6c738/period_compare.jpg 1200w\", \"/static/48ee45f47e226d1fe59a8baa6834b6ca/8b34c/period_compare.jpg 1800w\", \"/static/48ee45f47e226d1fe59a8baa6834b6ca/111a0/period_compare.jpg 2400w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Evaluation of Period\"), \"\\n  \")), mdx(\"p\", null, \"Everything seems in order for the periods so let's move onto looking at the energy of the system.\"), mdx(\"h3\", {\n    \"id\": \"energy-validation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Energy Validation\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#energy-validation\",\n    \"aria-label\": \"energy validation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Energy validation is even simpler, we already compute the energy alongside the history of states so we can just plot based on that. It's a given that we expect the total energy of the system to remain constant as there are no losses but what do we expect the kinetic energy and potential energy to look like? \"), mdx(\"p\", null, \"As the satellite is essentially the only object moving (Earth is getting pulled slightly but it's negligible) and it's orbit is circular we would expect the velocity and therefore the kinetic energy to remain constant. This would also mean that the potential energy would be constant so we should expect 3 constant values for KE, PE, and TE.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"energies = TwoBody.energies\\ntimes = np.arange(0, energies.shape[0]) * dt / 60\\nplt.plot(times, energies[:,0], label='KE')\\nplt.plot(times, energies[:,1], label='PE')\\nplt.plot(times, energies[:,2], label='TE')\\nplt.xlabel(\\\"Time (Mins)\\\")\\nplt.ylabel(\\\"Energy (Joules)\\\")\\nplt.legend()\\nplt.show()\\n\")), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/86c5ea2795abff9a3d2e68a62aab5610/111a0/twobody_energy.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3pAmP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAQACAwEAAAAAAAAAAAAAAAARIQFRYYH/2gAIAQEAAT8hx1TxC9of/9oADAMBAAIAAwAAABBTz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExQVGRwf/aAAgBAQABPxCiWNZXieou5iW6UgWfma5Wf//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Energy Trends For Two Body\",\n    \"title\": \"Energy Trends For Two Body\",\n    \"src\": \"/static/86c5ea2795abff9a3d2e68a62aab5610/6c738/twobody_energy.jpg\",\n    \"srcSet\": [\"/static/86c5ea2795abff9a3d2e68a62aab5610/73b64/twobody_energy.jpg 300w\", \"/static/86c5ea2795abff9a3d2e68a62aab5610/3ad8d/twobody_energy.jpg 600w\", \"/static/86c5ea2795abff9a3d2e68a62aab5610/6c738/twobody_energy.jpg 1200w\", \"/static/86c5ea2795abff9a3d2e68a62aab5610/8b34c/twobody_energy.jpg 1800w\", \"/static/86c5ea2795abff9a3d2e68a62aab5610/111a0/twobody_energy.jpg 2400w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Energy Trends For Two Body\"), \"\\n  \")), mdx(\"p\", null, \"Great! Seems like everything is working as expected so we can move on to some more interesting examples.\"), mdx(\"h1\", {\n    \"id\": \"special-three-body\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Special Three Body\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#special-three-body\",\n    \"aria-label\": \"special three body permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"In this section, we'll have fun with an N-body choreography with three bodies. The history of them is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.math.uni-bielefeld.de/~rehmann/ECM/cdrom/3ecm/pdfs/pant3/simo.pdf\",\n    \"target\": \"_self\",\n    \"rel\": \"nofollow\"\n  }, \"quite short\"), \" and many fun initial conditions have already been found. We're focusing on one that should produce a stable figure 8!\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"It's pretty typical for these to use $G=1$\")), mdx(\"h2\", {\n    \"id\": \"initial-conditions-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Initial Conditions\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#initial-conditions-1\",\n    \"aria-label\": \"initial conditions 1 permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I have provided the initial conditions and masses for this system in the form needed for our solution below. I chose this choreography as many of the other examples are quite unstable and may not provide good results.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"X = np.array([[-0.3092050,  0.        ,  0.        , -0.50436399],\\n              [ 0.1546025, -0.09875616, -1.18437049,  0.25218199],\\n              [ 0.1546025,  0.09875616,  1.18437049,  0.25218199]])\\nmasses = np.ones(3) * 1/3 # Total mass for the system is 1\\n\")), mdx(\"h2\", {\n    \"id\": \"running-simulation-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Running Simulation\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#running-simulation-1\",\n    \"aria-label\": \"running simulation 1 permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Just as before, we can construct an instance of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NBody\"), \" class and proceed with the simulation!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"Figure8 = NBody(Xi=X, masses=masses, G=1) # Note the different G\\nT, dt = 3.5, 1e-3\\nhistory = Figure8.run_simulation(T, dt)\\n\")), mdx(\"p\", null, \"We can go ahead and plot the results to see if we get the correct result.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Plot Position\\nfor i in range(3): # Iterate over the bodies\\n    x = history[:, i, 0]\\n    y = history[:, i, 1]\\n    plt.plot(x, y, linewidth=1, color='black', zorder=0)\\n    plt.plot(x, y, markevery=[0], marker=\\\"o\\\", ms=5, linewidth=0, color='black', \\n             mfc='blue', mec='blue', zorder=1)\\nplt.axis('equal')\\nplt.xlabel(\\\"X\\\")\\nplt.ylabel(\\\"Y\\\")\\nplt.tight_layout()\\nplt.show()\\n\")), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/7bfe3a54c09821e159cb86e1c0a6201e/111a0/figure8.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe80Sof/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAACAwEAAAAAAAAAAAAAAAAAEQEQQYH/2gAIAQEAAT8h2bR0R//aAAwDAQACAAMAAAAQQw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAACAwEBAQAAAAAAAAAAAAAAAREhMVFB8f/aAAgBAQABPxBelWT2Euj3ppw9IfwW1n//2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Stable Figure 8 Choreography\",\n    \"title\": \"Stable Figure 8 Choreography\",\n    \"src\": \"/static/7bfe3a54c09821e159cb86e1c0a6201e/6c738/figure8.jpg\",\n    \"srcSet\": [\"/static/7bfe3a54c09821e159cb86e1c0a6201e/73b64/figure8.jpg 300w\", \"/static/7bfe3a54c09821e159cb86e1c0a6201e/3ad8d/figure8.jpg 600w\", \"/static/7bfe3a54c09821e159cb86e1c0a6201e/6c738/figure8.jpg 1200w\", \"/static/7bfe3a54c09821e159cb86e1c0a6201e/8b34c/figure8.jpg 1800w\", \"/static/7bfe3a54c09821e159cb86e1c0a6201e/111a0/figure8.jpg 2400w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Stable Figure 8 Choreography\"), \"\\n  \")), mdx(\"p\", null, \"That looks great! I took the liberty of producing an animation of their motion and the associated energy as I think it's a great way to appreciate this case.\"), mdx(PostVideo, {\n    video: figure8,\n    mdxType: \"PostVideo\"\n  }), mdx(\"h1\", {\n    \"id\": \"partial-solar-system\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Partial Solar System\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#partial-solar-system\",\n    \"aria-label\": \"partial solar system permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Lastly, let's consider a partial solar system example. I limited this to a partial simulation as the periods of orbit for some of the outermost planets are quite long and I don't think it's reasonable for most people to run a full period of these orbits on their computers.\"), mdx(\"h2\", {\n    \"id\": \"initial-conditions-2\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Initial Conditions\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#initial-conditions-2\",\n    \"aria-label\": \"initial conditions 2 permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Much like the figure-8 case, I was able to find the initial conditions \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.wiu.edu/cas/mathematics_and_philosophy/graduate/equations-planetary-motion.pdf\",\n    \"target\": \"_self\",\n    \"rel\": \"nofollow\"\n  }, \"online\"), \" and I have provided them in the format needed for my simulation structure below.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"names = [\\\"Sun\\\", \\\"Mercury\\\", \\\"Venus\\\", \\\"Earth\\\", \\\"Mars\\\", \\\"Jupiter\\\", \\\"Saturn\\\", \\\"Uranus\\\",\\n        \\\"Neptune\\\", \\\"Pluto\\\"]\\nX = np.array([\\n    [1.81899E+8, 9.83630E+8, -1.58778E+8, -1.12474E+1, 7.54876E+0, 2.68723E-1],\\n    [-5.67576E+10, -2.73592E+10, 2.89173E+9, 1.16497E+4, -4.14793E+4, -4.45952E+3],\\n    [4.28480E+10, 1.00073E+11, -1.11872E+09, -3.22930E+04, 1.36960E+04, 2.05091E+03],\\n    [-1.43778E+11, -4.00067E+10, -1.38875E+07, 7.65151E+03, -2.87514E+04, 2.08354E+00],\\n    [-1.14746E+11, -1.96294E+11, -1.32908E+09, 2.18369E+04, -1.01132E+04, -7.47957E+02],\\n    [-5.66899E+11, -5.77495E+11, 1.50755E+10, 9.16793E+03, -8.53244E+03, -1.69767E+02],\\n    [8.20513E+10, -1.50241E+12, 2.28565E+10, 9.11312E+03, 4.96372E+02, -3.71643E+02],\\n    [2.62506E+12, 1.40273E+12, -2.87982E+10, -3.25937E+03, 5.68878E+03, 6.32569E+01],\\n    [4.30300E+12, -1.24223E+12, -7.35857E+10, 1.47132E+03, 5.25363E+03, -1.42701E+02],\\n    [1.65554E+12, -4.73503E+12, 2.77962E+10, 5.24541E+03, 6.38510E+02, -1.60709E+03]\\n])\\nmasses = np.array([1.98854E+30, 3.30200E+23, 4.86850E+24, 5.97219E+24, 6.41850E+23,\\n                  1.89813E+27, 5.68319E+26, 8.68103E+25, 1.02410E+26, 1.30700E+22])\\n\\n# You can subset out the planets\\nn = 5 # Number of planets to remove from the end\\nnames = names[:-n]\\nX = X[:-n]\\nmasses = masses[0:-n]\\n\")), mdx(\"h2\", {\n    \"id\": \"running-simulation-2\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Running Simulation\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#running-simulation-2\",\n    \"aria-label\": \"running simulation 2 permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The process here is identical to before, but given the scale of the problem notice how the timestep is much larger now. I try to scale my timestep based on the periods where over a period I want a certain number of steps. Playing with this more you can develop better intuition behind this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Time Step is an hour!\\nSolarSystem = NBody(Xi=X, masses=masses)\\nT, dt = 2 * 365 * 24 * 60**2, 60 ** 2 # 2 Years, 1 hour step\\nhistory = SolarSystem.run_simulation(T, dt)\\n\")), mdx(\"p\", null, \"Now that we have the history we can go ahead and produce a test plot.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"fig = plt.figure(figsize=(7,7))\\nax = fig.add_subplot(111,projection='3d')\\ncolors = [\\\"yellow\\\", \\\"gray\\\", \\\"orange\\\", \\\"deepskyblue\\\", \\\"red\\\", \\\"chocolate\\\", \\n          \\\"bisque\\\", \\\"lightcyan\\\", \\\"blue\\\", \\\"lightgray\\\"]\\nfor i in range(X.shape[0]):\\n    c = colors[i]\\n    x = history[:, i, 0]\\n    y = history[:, i, 1]\\n    z = history[:, i, 2]\\n    ax.plot3D(x, y, z, color='gray', label=names[i], linewidth=0.2,\\n             markevery=[0], marker='o', ms=10, mfc=c, mec=\\\"black\\\", mew=0.5)\\n    \\nax.set(xlabel='X')\\nax.set(ylabel='Y')\\nax.set(zlabel='Z')\\n\\nax.grid(False) # Turn off grid\\nax.w_xaxis.set_pane_color((0.0, 0.0, 0.0, 0.0)) # No color on face x axis face\\nax.w_yaxis.set_pane_color((0.0, 0.0, 0.0, 0.0)) # No color on face y axis face\\nax.w_zaxis.set_pane_color((0.0, 0.0, 0.0, 0.0)) # No color on face z axis face\\n    \\nax.legend(markerscale=0.375)\\nplt.show()\\n\")), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/91e15/solar_system_test.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"100%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3wRQAB//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAEFAh//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAWEAADAAAAAAAAAAAAAAAAAAABECD/2gAIAQEAAT8hQv8A/9oADAMBAAIAAwAAABDDDzz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAaEAACAwEBAAAAAAAAAAAAAAAAARARMSFB/9oACAEBAAE/EIslW9G/LMEt4UUo/9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Partial Solar System\",\n    \"title\": \"Partial Solar System\",\n    \"src\": \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/6c738/solar_system_test.jpg\",\n    \"srcSet\": [\"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/73b64/solar_system_test.jpg 300w\", \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/3ad8d/solar_system_test.jpg 600w\", \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/6c738/solar_system_test.jpg 1200w\", \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/8b34c/solar_system_test.jpg 1800w\", \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/111a0/solar_system_test.jpg 2400w\", \"/static/a248b6e2a2f0e0bb33ba570f9cca6c57/91e15/solar_system_test.jpg 2800w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Partial Solar System\"), \"\\n  \")), mdx(\"p\", null, \"In my animation, I did some extra work to try and scale the sizes of the planets with some respect to their actual sizes but I opted not to for the example here as it just adds unnecessary complexity for plotting the example for validation purposes.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Little challenge for you, plot the energy for this system and see if it makes sense to you.\")), mdx(\"h1\", {\n    \"id\": \"closing-remarks\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Closing Remarks\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#closing-remarks\",\n    \"aria-label\": \"closing remarks permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This one was quite a bit to write but I hope you enjoyed reading it as much as I did making it. Let me know if you have any suggestions or comments and I'd be happy to consider them.\"), mdx(\"p\", null, mdx(\"figure\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-figure\",\n    \"style\": {}\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"878px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/cf7ba7687386ea3c6767889c59bf72a8/faa4f/orbital_mechanics_meme.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAABibAAAYmwFJdYOUAAAB4ElEQVQoz12SW4+iQBCF/f//w2RW3QdjFKPBRIM30EQQGkEjaWwuSoNCwAkoW5uhd9xdv8fqOudUVbpmWVaWZXEcJ0mSpqmqqgghRVGOx6NhGIIgrNdrQRAOh8Or7Xa75Xm+Wq1qlFIA+FUBAMfjsd1ut1qt6XQ6GAyazWaj0ej3+1EUsTYAKMsSAHRdr7muWxTFq1QUBSHkfD5fLpcwDCmlGOMkSQDgswIAns8nACCEahjj6/X6Cmfeb7AiG/i/ZNu24zh+dQRB4Ps+63jBniileZ6/i5kfAKRpOqpglbcpPM973/lfsed5Pyocx2G3TdOUXfR+vwdBwBwfj8cfMcY4TVPXdRFCj8eDUmpZVhRFw+Gw0+lwHCeKIgAwIyb+m0wIsW17PB4Ph8P1eo0xDio2m81qtZpMJixQ1/XFYiGKommakiSdTqfdbvcl9n1/Pp+PRqNer2dZ1n6/P51Ovu+XZcmGt21bkqR6vc5x3GQy+fj4IISYplmzLItSWhSFruubzSYMwyzL3k5VlmUcxzzP/6zQdR0ANE2rBUHgOA75hlLK1pNleblcEkKiKEoqwjBkn4f9tq+xBUFACG23W4SQpmmqqiqKommaIAg8z89mM1mWt9+oFbIsG4bR7XZ/A2TUvPlmNpkSAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Where Are You?\",\n    \"title\": \"Where Are You?\",\n    \"src\": \"/static/cf7ba7687386ea3c6767889c59bf72a8/faa4f/orbital_mechanics_meme.png\",\n    \"srcSet\": [\"/static/cf7ba7687386ea3c6767889c59bf72a8/eed55/orbital_mechanics_meme.png 300w\", \"/static/cf7ba7687386ea3c6767889c59bf72a8/7491f/orbital_mechanics_meme.png 600w\", \"/static/cf7ba7687386ea3c6767889c59bf72a8/faa4f/orbital_mechanics_meme.png 878w\"],\n    \"sizes\": \"(max-width: 878px) 100vw, 878px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\n    \", mdx(\"figcaption\", {\n    parentName: \"figure\",\n    \"className\": \"gatsby-resp-image-figcaption\"\n  }, \"Where Are You?\"), \"\\n  \")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"N-Body Orbit Simulation","date":"October 2nd, 2022","excerpt":"An introduction to the principles and methods required to implement an n-body simulator in Python.","featureImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG+AAAD/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQABBQIf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwIf/8QAFhAAAwAAAAAAAAAAAAAAAAAAARAg/9oACAEBAAE/IUL/AP/aAAwDAQACAAMAAAAQ4M88/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAGRABAAMBAQAAAAAAAAAAAAAAAQAQESEx/9oACAEBAAE/EKCGLvYzzYFYV//Z"},"images":{"fallback":{"src":"/static/35be3cc96917708eb36141989f4f43e0/baaed/solar_system_large.jpg","srcSet":"/static/35be3cc96917708eb36141989f4f43e0/dd515/solar_system_large.jpg 200w,\n/static/35be3cc96917708eb36141989f4f43e0/47930/solar_system_large.jpg 400w,\n/static/35be3cc96917708eb36141989f4f43e0/baaed/solar_system_large.jpg 800w,\n/static/35be3cc96917708eb36141989f4f43e0/b26d3/solar_system_large.jpg 1600w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[]},"width":800,"height":800}}}},"fields":{"path":"/blog/nbody/","readingTime":{"text":"48 min read"}},"tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#prior-knowledge","title":"Prior Knowledge"},{"url":"#n-body-problem","title":"N-Body Problem"},{"url":"#general-goals","title":"General Goals"},{"url":"#notation","title":"Notation"},{"url":"#gravity-laws","title":"Gravity Laws","items":[{"url":"#law-of-universal-gravitation","title":"Law of Universal Gravitation"},{"url":"#force-on-one-body","title":"Force on One Body"},{"url":"#acceleration-on-one-body","title":"Acceleration on One Body"},{"url":"#acceleration-for-all-bodies","title":"Acceleration for All Bodies"}]},{"url":"#system-energies","title":"System Energies","items":[{"url":"#kinetic-energy","title":"Kinetic Energy"},{"url":"#potential-energy","title":"Potential Energy"}]},{"url":"#system-state","title":"System State","items":[{"url":"#structure","title":"Structure"},{"url":"#state-derivative","title":"State Derivative"},{"url":"#advantages","title":"Advantages"},{"url":"#simple-example","title":"Simple Example"}]},{"url":"#integrator-refresher","title":"Integrator Refresher","items":[{"url":"#general-form","title":"General Form"},{"url":"#mass-spring-system","title":"Mass-Spring System"}]},{"url":"#executing-a-simulation","title":"Executing a Simulation","items":[{"url":"#number-of-iterations","title":"Number of Iterations"},{"url":"#initializations","title":"Initializations"},{"url":"#running-iterations","title":"Running Iterations"}]},{"url":"#implementation","title":"Implementation","items":[{"url":"#simulation-class","title":"Simulation Class"},{"url":"#init","title":"Init"},{"url":"#system-energy","title":"System Energy"},{"url":"#state-derivative-1","title":"State Derivative"},{"url":"#rk4-integrator","title":"RK4 Integrator"},{"url":"#running-the-simulation","title":"Running the Simulation"}]},{"url":"#simple-two-body--verification","title":"Simple Two Body & Verification","items":[{"url":"#initial-conditions","title":"Initial Conditions"},{"url":"#running-simulation","title":"Running Simulation"},{"url":"#validation","title":"Validation"}]},{"url":"#special-three-body","title":"Special Three Body","items":[{"url":"#initial-conditions-1","title":"Initial Conditions"},{"url":"#running-simulation-1","title":"Running Simulation"}]},{"url":"#partial-solar-system","title":"Partial Solar System","items":[{"url":"#initial-conditions-2","title":"Initial Conditions"},{"url":"#running-simulation-2","title":"Running Simulation"}]},{"url":"#closing-remarks","title":"Closing Remarks"}]}},"site":{"siteMetadata":{"title":"Patrick Youssef"}}},"pageContext":{"post_id":"/blog/nbody/"}},"staticQueryHashes":[]}